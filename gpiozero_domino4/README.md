# 임베디드 통신시스템 프로젝트 - gpiozero 기반 domino4

이 프로젝트는 Raspberry Pi 5와 Python의 `gpiozero` 라이브러리를 활용하여 GPIO를 제어하는 것을 목표로 합니다.  
본 문서에서는 전체 코드의 로직과 하드웨어 연결 구성에 대해 기술합니다.  
특히 **domino4**는 4개의 GPIO 핀을 사용하여 LED들이 순차적으로 켜졌다가 꺼지는 동작을 구현하는 프로젝트입니다.

---

## 시연 영상

실제 작동하는 모습을 아래 영상을 통해 확인할 수 있습니다:

[![시연 영상 바로가기](http://img.youtube.com/vi/z2csX5kX4zo/0.jpg)](https://youtu.be/9MFR2cRm7uk)

### 핀맵과 GPIO에 대한 추가 설명입니다.
[![시연 영상 바로가기](http://img.youtube.com/vi/bRw7eX6XiOk/0.jpg)](https://youtu.be/bRw7eX6XiOk)

---

## 동작 원리 상세 설명

본 프로젝트의 핵심 동작은 **순차 토글**입니다.  
지정된 4개의 GPIO 핀에 연결된 LED들이 배열 순서대로 하나씩 점등되며,  
1초간 유지된 후 소등되는 과정을 무한히 반복합니다.

- **순차 토글 동작:**  
  - **1단계:** 배열의 첫 번째 핀(GPIO 5)이 HIGH → LED 1 점등 → 1초 후 소등  
  - **2단계:** 두 번째 핀(GPIO 6)이 HIGH → LED 2 점등 → 1초 후 소등  
  - **3단계:** 세 번째 핀(GPIO 13)이 HIGH → LED 3 점등 → 1초 후 소등  
  - **4단계:** 네 번째 핀(GPIO 19)이 HIGH → LED 4 점등 → 1초 후 소등

- **안전 종료 처리:**  
  - SIGINT (Ctrl+C) 또는 SIGTERM 시그널이 발생하면, `cleanup()` 함수가 실행되어 모든 GPIO 핀을 LOW로 전환하고 안전하게 종료됩니다.

---

## 하드웨어 구성 설명

### 실제 구성 이미지
![실제 하드웨어 구성 이미지](../image/ECS_count8_domino4_real.png.jpg)

### 하드웨어 구성 도식화
![하드웨어 구성 도식화](../image/ECS_count8_domino4.png)

### Raspberry Pi5 pinmap
![라즈베리파이5 핀맵](../image/RaspberryPi5pin_map.png)

### GPIO 핀 연결 표

| 핀 번호 (BCM) | 연결된 부품 | 설명                              |
|---------------|------------|-----------------------------------|
| GPIO 5        | LED 1      | 순차 토글 동작의 첫 번째 LED        |
| GPIO 6        | LED 2      | 순차 토글 동작의 두 번째 LED        |
| GPIO 13       | LED 3      | 순차 토글 동작의 세 번째 LED        |
| GPIO 19       | LED 4      | 순차 토글 동작의 네 번째 LED        |

> **핵심:**  
> 이 구성은 4개의 핀을 사용하여 LED들이 순차적으로 켜졌다 꺼지는 시퀀스를 구현합니다.  
> 각 LED는 해당 GPIO 핀의 제어에 따라 1초간 점등 후 소등되어, 도미노처럼 연속적인 효과를 나타냅니다.

---

## 코드 설명 및 로직

아래 코드는 Python의 `gpiozero` 라이브러리를 사용하여  
4개의 GPIO 핀(5, 6, 13, 19)에 연결된 LED를 순차적으로 점등하고 소등하는 기능을 구현합니다.

```python
#!/usr/bin/env python3
# 이 줄은 이 스크립트를 실행할 때 사용할 인터프리터를 지정합니다.
# '/usr/bin/env'는 시스템 환경변수 PATH에 따라 'python3'를 자동 탐색해서 실행합니다.
# 즉, 이 코드는 다양한 시스템에서도 이식성 있게 실행될 수 있도록 합니다.

from gpiozero import LED
# gpiozero는 Raspberry Pi 전용으로 설계된 고수준 GPIO 제어 라이브러리입니다.
# LED 클래스는 GPIO 핀을 출력으로 설정하고, 그 핀에 연결된 LED나 출력장치를 간단히 제어할 수 있게 해줍니다.

from signal import signal, SIGINT, SIGTERM
# signal 모듈은 운영체제에서 전달되는 시그널을 감지하고, 사용자가 정의한 함수로 처리할 수 있도록 해줍니다.
# SIGINT는 사용자가 Ctrl+C를 누를 때 발생하는 시그널입니다.
# SIGTERM은 프로세스 종료 요청(kill 명령 등)이 들어올 때 발생하는 시그널입니다.

from time import sleep
# sleep 함수는 프로그램의 실행을 잠시 중단시킵니다.
# 이 예제에서는 LED 점등 상태를 1초 동안 유지하기 위해 사용됩니다.

import sys
# sys.exit()를 통해 프로그램을 안전하게 종료할 수 있도록 하기 위한 모듈입니다.

# ----------------------------------------------------------
# 1. 사용하고자 하는 GPIO 핀 리스트 정의 (BCM 번호 기준)
# ----------------------------------------------------------
# Raspberry Pi에는 두 가지 핀 넘버링 방식이 있는데, BCM은 Broadcom 칩셋 내부 번호를 따릅니다.
# gpio_pins 리스트는 사용하고자 하는 GPIO 핀 번호들을 담고 있습니다.
# 이 순서대로 LED를 제어하게 됩니다.
gpio_pins = [5, 6, 13, 19]

# ----------------------------------------------------------
# 2. 각 핀에 대응되는 LED 객체 생성
# ----------------------------------------------------------
# LED(pin) 을 호출하면 해당 GPIO 핀을 출력 모드로 설정하고, 객체를 통해 ON/OFF 제어가 가능해집니다.
# 리스트 컴프리헨션을 사용하여 leds라는 리스트에 네 개의 LED 객체를 생성합니다.
# 예: leds[0]은 GPIO 5번을 제어하는 LED 객체입니다.
leds = [LED(pin) for pin in gpio_pins]

# ----------------------------------------------------------
# 3. 종료 시 실행될 함수 정의 (안전 종료 처리)
# ----------------------------------------------------------
def cleanup(signum, frame):
    """
    시스템 시그널(SIGINT 또는 SIGTERM)을 수신하면 실행되는 함수입니다.
    모든 GPIO 핀을 LOW 상태로 설정하여 LED를 소등하고,
    시스템 자원을 정리한 후 프로그램을 종료합니다.

    Parameters:
    - signum: 발생한 시그널 번호
    - frame: 현재 코드의 실행 상태(디버깅용, 여기선 사용하지 않음)
    """
    print("\n종료 중: GPIO 핀 LOW로 초기화 중...")
    for led in leds:
        led.off()  # 해당 GPIO 핀을 LOW 상태로 만들어 LED를 끕니다.
    sys.exit(0)  # 프로그램을 정상적으로 종료합니다.

# ----------------------------------------------------------
# 4. 시그널 핸들러 등록 (Ctrl+C 또는 시스템 종료 요청 감지)
# ----------------------------------------------------------
# signal 함수는 운영체제가 시그널을 보냈을 때 어떤 함수를 실행할지를 정의합니다.
# 여기서는 Ctrl+C 또는 kill 명령어가 들어오면 cleanup() 함수가 실행되도록 설정합니다.
signal(SIGINT, cleanup)    # 키보드 인터럽트 (Ctrl+C)
signal(SIGTERM, cleanup)   # 종료 시그널 (kill 명령 등)

# ----------------------------------------------------------
# 5. LED 순차 점등 함수 정의
# ----------------------------------------------------------
def toggle_sequence():
    """
    이 함수는 4개의 LED를 리스트에 저장된 순서대로 하나씩 점등(on)하고,
    1초간 점등 상태를 유지한 뒤 소등(off)하는 동작을 수행합니다.
    도미노처럼 LED가 순서대로 켜졌다가 꺼지는 시각적 효과를 줍니다.
    """
    for led in leds:       # leds 리스트에 있는 각 LED 객체에 대해 반복 수행
        led.on()           # 해당 LED를 켭니다 (GPIO HIGH)
        sleep(1)           # 1초 대기 (LED 점등 유지)
        led.off()          # 해당 LED를 끕니다 (GPIO LOW)

# ----------------------------------------------------------
# 6. 프로그램 메인 루프
# ----------------------------------------------------------
try:
    # 무한 루프를 통해 toggle_sequence()를 반복 실행합니다.
    # 사용자가 Ctrl+C를 누르거나 시스템 종료 시그널이 발생할 때까지 계속 LED가 순차적으로 점등됩니다.
    while True:
        toggle_sequence()

# ----------------------------------------------------------
# 7. 예외 처리 (Ctrl+C 시 명시적 종료)
# ----------------------------------------------------------
except KeyboardInterrupt:
    # try 블록 안에서 Ctrl+C를 누르면 KeyboardInterrupt 예외가 발생하고,
    # 이 블록으로 넘어와 cleanup 함수를 수동으로 호출하여 안전하게 종료합니다.
    cleanup(None, None)
```

---

## 라이선스

이 프로젝트는 [MIT License](../LICENSE) 하에 오픈소스로 공개됩니다.
